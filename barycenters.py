import numpy as np

class LOTBarycenter:
    @staticmethod
    def generate_barycenters(pclouds : np.array, labels: np.array, weights = None, n = 20):
        """
        Generate barycenters of point clouds based on given or randomly generated weights.

        Parameters
        ----------
        pclouds : np.array
            A 2D array where each row represents a point cloud.
            Shape: (number_of_point_clouds, number_of_features)
        
        labels : np.array
            A 1D array of labels corresponding to the point clouds in `pclouds`.
            Shape: (number_of_point_clouds,)
        
        weights : list of np.array, optional
            A list of weight vectors for generating barycenters. Each weight vector is used to linearly combine 
            the point clouds in a particular class. If `weights` is not provided, random weights will be generated.
            Default is None.
        
        n : int, optional
            The number of random weight vectors to generate for each unique label if `weights` is not provided.
            Default is 20.

        Returns
        -------
        barycenters : np.array
            A 2D array where each row is a barycenter generated by combining point clouds in `pclouds` according 
            to the corresponding weight vector. Shape: (number_of_barycenters, number_of_features)
        
        output_labels : np.array
            A 1D array of labels corresponding to the generated barycenters. Shape: (number_of_barycenters,)
        
        weights : np.array
            A 2D array of the weight vectors used to generate the barycenters. Shape: (number_of_barycenters, sample_size)
            `sample_size` is the number of point clouds used to generate each barycenter.

        Notes
        -----
        - If `weights` are provided, the function will use them to generate barycenters; otherwise, it will generate random weights.
        - The function assumes that the number of point clouds in each class is at least equal to the sample size implied by the provided or generated weights.

        """

        unique_labels = np.unique(labels)

        # Generate n random weights for each unique label.
        if(weights is None):
            weights = []
            output_labels = []

            for label in unique_labels:
                pclouds_class = pclouds[labels == label]
                output_labels += [label] * n

                for _ in range(n):
                    lambd = np.random.rand(pclouds_class.shape[0]) # weight vec length = # of point cloud in each class
                    lambd /= lambd.sum()
                    weights.append(lambd)

        # Generate barycenters using given weights
        barycenters = []

        for label in unique_labels:
            pclouds_class = pclouds[labels == label]
            for weight in weights:
                barycenters.append(weight @ pclouds_class[:weight.shape[1]]) # sample size depends on given weight, default is set to class size. 

        return np.array(barycenters), np.array(output_labels), np.array(weights)
                